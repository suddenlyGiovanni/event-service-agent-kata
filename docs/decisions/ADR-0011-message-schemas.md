# ADR-0011: Message Schema Validation with Effect Schema

- Status: Accepted
- Date: 2025-10-24
- Context: PL-4.4 (Timer polling workflow), PL-14 (full migration)

---

## Problem

Current message definitions (`packages/contracts/src/messages/messages.ts`) use plain TypeScript interfaces with const enum discriminators. This provides:

- ✅ Type-level safety (compile-time)
- ❌ No runtime validation
- ❌ No parsing from wire format (JSON → Domain)
- ❌ No encoding to wire format (Domain → JSON)
- ❌ Manual construction prone to errors (typos, invalid data)
- ❌ No invariant enforcement (e.g., non-empty strings, valid timestamps)

When implementing adapters (e.g., `timer-event-bus.adapter.ts`), developers must:

1. Manually construct objects matching interface shape
2. Hope data is valid (no runtime checks)
3. Write custom encoding/decoding logic
4. Risk runtime failures from invalid data

**Core Issue**: Plain interfaces conflate two concerns:

- **DTO shape** (wire format documentation)
- **Domain validation** (runtime guarantees)

Domain Modeling Made Functional (DMMF) principle: **"Parse, Don't Validate"** — transform untrusted input into trusted domain types once at boundaries.

---

## Context

### Current Architecture

```typescript
// packages/contracts/src/messages/messages.ts
interface DueTimeReached extends Event<Type.DueTimeReached> {
  readonly reachedAt?: Iso8601DateTime.Type;
}

// Adapter usage (NO validation)
const event: Timer.Events.DueTimeReached = {
  type: "DueTimeReached",
  tenantId: rawData.tenantId, // ⚠️ Could be invalid!
  serviceCallId: rawData.serviceCallId,
  reachedAt: rawData.reachedAt,
};
```

### Effect Schema Solution

Effect Schema implements DMMF "Parse, Don't Validate" pattern:

```typescript
// Domain event as validated Schema
class DueTimeReached extends Schema.TaggedClass<DueTimeReached>()(
  "DueTimeReached",
  {
    tenantId: TenantId, // Branded, validated
    serviceCallId: ServiceCallId, // Branded, validated
    reachedAt: Schema.optional(Iso8601DateTime),
  },
) {}

// At adapter boundary (parse once)
const event = yield * Schema.decode(DueTimeReached)(rawData);
//    ^^^^^ Either succeeds (valid) or fails (ParseError)

// Domain receives GUARANTEED valid event
yield * workflow.handle(event);
```

### Related Decisions

- **ADR-0010**: Identity generation (UUID7, application-generated)
- **ADR-0006**: Idempotency (keying by tenantId + serviceCallId)
- Hexagonal architecture: Parse at adapter boundaries

---

## Decision

**Adopt Effect Schema for all domain messages (events and commands)** using incremental migration:

### 1. Module Ownership

Each module owns its message schemas:

```
packages/
  timer/src/domain/
    events.domain.ts          ← export class DueTimeReached
  orchestration/src/domain/
    events.domain.ts          ← Orchestration events
    commands.domain.ts        ← Orchestration commands
  execution/src/domain/
    events.domain.ts          ← Execution events
  api/src/domain/
    commands.domain.ts        ← API commands
```

### 2. Schema Class Pattern

Use `Schema.TaggedClass` with **direct field repetition** (Option A from analysis):

```typescript
export class DueTimeReached extends Schema.TaggedClass<DueTimeReached>()(
  "DueTimeReached",
  {
    tenantId: TenantId, // Base field (repeated)
    serviceCallId: ServiceCallId, // Base field (repeated)
    reachedAt: Schema.optional(Iso8601DateTime), // Event-specific
  },
) {}
```

**Rationale**:

- Only 2 base fields (`tenantId`, `serviceCallId`) — repetition acceptable
- Explicit and obvious (no magic)
- No abstraction tax
- Can refactor to helper function later if pattern emerges

**Commands that create aggregates** omit `serviceCallId`:

```typescript
export class SubmitServiceCall extends Schema.TaggedClass<SubmitServiceCall>()(
  "SubmitServiceCall",
  {
    tenantId: TenantId,
    // NO serviceCallId - will be generated by Orchestration
    name: Schema.NonEmpty,
    dueAt: Iso8601DateTime,
    requestSpec: RequestSpec,
  },
) {}
```

#### Schema Class Conventions

**Static Methods** (for ergonomics):

```typescript
export class DueTimeReached extends Schema.TaggedClass<DueTimeReached>()(
  "DueTimeReached",
  {
    tenantId: TenantId,
    serviceCallId: ServiceCallId,
    reachedAt: Schema.optional(Iso8601DateTime),
  },
) {
  /**
   * Decode from unknown (wire format → validated domain)
   * Returns Effect<DueTimeReached, ParseError>
   */
  static readonly decode = Schema.decode(DueTimeReached);

  /**
   * Encode to wire format (validated domain → JSON-serializable)
   * Returns Effect<DueTimeReachedDTO, ParseError>
   */
  static readonly encode = Schema.encode(DueTimeReached);

  /**
   * Safe constructor (alternative to `new DueTimeReached(...)`)
   * Validates at construction time
   */
  // static readonly make = (props: {
  //   tenantId: TenantId.Type
  //   serviceCallId: ServiceCallId.Type
  //   reachedAt?: Iso8601DateTime.Type
  // }) => new DueTimeReached(props)
}
```

**Usage**:

```typescript
// Decode from wire
const event = yield * DueTimeReached.decode(jsonData);

// Construct in domain
const event = DueTimeReached.make({
  tenantId,
  serviceCallId,
  reachedAt: Option.some(now),
});

// Encode for wire
const dto = yield * DueTimeReached.encode(event);
```

**Type Namespace Pattern** (match current messages.ts structure):

**DTO Type Exports** (for adapter boundaries):

```typescript
// Domain type (validated, used in workflows)
export type DueTimeReached = Schema.Schema.Type<
  typeof Timer.Events.DueTimeReached
>;

// DTO type (wire format, used in adapters)
export type DueTimeReachedDTO = Schema.Schema.Encoded<
  typeof Timer.Events.DueTimeReached
>;
// Inferred type:
// {
//   type: 'DueTimeReached'
//   tenantId: string        // ← Unbrand for serialization
//   serviceCallId: string   // ← Unbrand for serialization
//   reachedAt?: string      // ← ISO8601 string
// }
```

### 3. Central Registry (Contracts Package)

Create `packages/contracts/src/messages/schemas.ts` exporting Schema unions:

```typescript
import { DueTimeReached } from "@event-service-agent/timer/domain";
import { ServiceCallScheduled } from "@event-service-agent/orchestration/domain";
// ... import all schemas

export const DomainEvent = Schema.Union(
  DueTimeReached,
  ServiceCallScheduled,
  // ... all events
);

export const DomainCommand = Schema.Union(
  StartExecution,
  ScheduleTimer,
  SubmitServiceCall,
);

export const DomainMessage = Schema.Union(DomainEvent, DomainCommand);

export type DomainEvent = Schema.Schema.Type<typeof DomainEvent>;
export type DomainCommand = Schema.Schema.Type<typeof DomainCommand>;
export type DomainMessage = Schema.Schema.Type<typeof DomainMessage>;
```

**Usage in Broker Adapter**:

```typescript
const decodeMessage = Schema.decode(DomainMessage);

function handleIncoming(raw: unknown) {
  return Effect.gen(function* () {
    const message = yield* decodeMessage(raw);
    //    ^^^^^^^ DomainEvent | DomainCommand (validated!)

    // Type-safe routing (exhaustive switch)
    switch (message.type) {
      case "DueTimeReached":
        return yield* routeToOrchestration(message);
      case "StartExecution":
        return yield* routeToExecution(message);
      // TypeScript enforces exhaustiveness
    }
  });
}
```

### 4. Keep Interface Documentation

**Retain** `packages/contracts/src/messages/messages.ts` as DTO reference:

- Provides wire format documentation
- Useful for contract discussions
- Does NOT drive implementation (schemas do)

### 5. Incremental Migration

**Phase 1** (PL-4.4): Timer module only

- Create `packages/timer/src/domain/events.domain.ts`
- Define `DueTimeReached` schema
- Use in `timer-event-bus.adapter.ts`
- **Proof of concept** for pattern

**Phase 2** (PL-14): All modules

- Migrate remaining events/commands to schemas
- Create `contracts/src/messages/schemas.ts` unions
- Update broker adapter for type-safe routing
- Estimated: 2-4 hours

---

## Consequences

### Positive

✅ **Runtime Safety**: Impossible to construct invalid messages  
✅ **Boundary Parsing**: Single validation point (adapters)  
✅ **Type-Safe Routing**: Discriminated unions in broker  
✅ **Encode/Decode**: Automatic JSON serialization  
✅ **Invariant Enforcement**: Non-empty strings, valid timestamps, branded types  
✅ **DMMF Compliance**: "Parse, Don't Validate" pattern  
✅ **Incremental**: Migrate module-by-module (low risk)  
✅ **Module Autonomy**: Each module owns its contracts

### Negative

⚠️ **Learning Curve**: Developers must understand Effect Schema  
⚠️ **Field Repetition**: Base fields (`tenantId`, `serviceCallId`) repeated in every schema  
⚠️ **Migration Effort**: ~2-4 hours for full migration (9 events + 3 commands)  
⚠️ **Dependency**: Couples domain to Effect Schema (acceptable given Effect-TS stack commitment)

### Neutral

- Plain interfaces remain as documentation (dual representation)
- Broker adapter needs Schema.Union support (one-time change)
- Test fixtures may need updates (construct via Schema instead of plain objects)

---

## Implementation Notes

### Base Schema Pattern (Deferred)

Current decision: **Direct repetition** (Option A)

If repetition becomes painful (>5 base fields), consider:

- **Option B**: `EventBase.fields` spread pattern
- **Option C**: `defineEvent()` helper function

Revisit if base fields grow beyond current 2 fields.

### HTTP Request Schemas

`RequestSpec` and `RequestSpecWithoutBody` need Schema definitions:

```typescript
// packages/contracts/src/types/http.type.ts
export class RequestSpec extends Schema.Class<RequestSpec>("RequestSpec")({
  method: Schema.Literal("GET", "POST", "PUT", "PATCH", "DELETE"),
  url: Schema.String,
  headers: Schema.optional(
    Schema.Record({ key: Schema.String, value: Schema.String }),
  ),
  body: Schema.optional(Schema.String),
}) {}

export class RequestSpecWithoutBody extends Schema.Class<RequestSpecWithoutBody>(
  "RequestSpecWithoutBody",
)({
  method: Schema.Literal("GET", "POST", "PUT", "PATCH", "DELETE"),
  url: Schema.String,
  headers: Schema.optional(
    Schema.Record({ key: Schema.String, value: Schema.String }),
  ),
  bodySnippet: Schema.optional(Schema.String),
}) {}
```

### Error Metadata Schemas

`ResponseMeta` and `ErrorMeta` (used in events) need schemas:

```typescript
export class ResponseMeta extends Schema.Class<ResponseMeta>("ResponseMeta")({
  status: Schema.Number,
  headers: Schema.optional(
    Schema.Record({ key: Schema.String, value: Schema.String }),
  ),
  bodySnippet: Schema.optional(Schema.String),
  latencyMs: Schema.optional(Schema.Number),
}) {}

export class ErrorMeta extends Schema.Class<ErrorMeta>("ErrorMeta")({
  kind: Schema.String,
  message: Schema.optional(Schema.String),
  details: Schema.optional(
    Schema.Record({ key: Schema.String, value: Schema.Unknown }),
  ),
  latencyMs: Schema.optional(Schema.Number),
}) {}
```

---

## Alternatives Considered

### A. Keep Plain Interfaces + Manual Validation

**Rejected**: Scatters validation logic, error-prone, no compile-time guarantee of validation coverage.

### B. Zod Schemas

**Rejected**: Effect Schema is native to Effect-TS ecosystem, provides:

- Better integration with Effect runtime
- Branded types support
- Schema.TaggedClass for discriminated unions
- Consistent with codebase stack

### C. io-ts

**Rejected**: Older approach, Effect Schema is more ergonomic and better maintained.

### D. JSON Schema + Codegen

**Rejected**: Adds tooling complexity, loses type-level expressiveness, not idiomatic for Effect-TS.

---

## References

- [Domain Modeling Made Functional](https://pragprog.com/titles/swdddf/domain-modeling-made-functional/) by Scott Wlaschin
- [Effect Schema Documentation](https://effect.website/docs/schema/introduction)
- [Parse, Don't Validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/) by Alexis King
- ADR-0010: Identity Generation Strategy (UUID7, branded types)
- ADR-0006: Idempotency Strategy (tenantId + serviceCallId keying)

---

## Tracking

- **Proposed**: PL-4.4 (2025-10-24) — Timer implementation revealed interface limitations
- **Accepted**: 2025-10-24 — Hybrid approach: Timer now, full migration PL-14
- **Implementation**:
  - Phase 1 (PL-4.4): Timer `DueTimeReached` schema ✅
  - Phase 2 (PL-14): Full migration (Inbox)
