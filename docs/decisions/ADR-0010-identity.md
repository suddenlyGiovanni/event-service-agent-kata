# ADR-0010: Identity Generation Strategy

Status: Accepted

## Problem

Who generates entity identifiers (TenantId, ServiceCallId, CorrelationId, EnvelopeId) and when? Options include:

1. **Client-generated** — External systems provide IDs
2. **Application-generated** — Application code creates IDs before persistence
3. **Database-generated** — Database assigns IDs on INSERT (AUTOINCREMENT, SERIAL, triggers)
4. **Broker-generated** — Message broker assigns IDs during publish

Each approach has implications for idempotency, event correlation, outbox pattern, and API contracts.

## Context

### System Requirements

- **Event-driven architecture** — At-least-once delivery, idempotent processing ([ADR-0006][])
- **Outbox pattern** — Publish domain events within database transaction ([ADR-0008][])
- **Multi-tenant** — All aggregates keyed by `(tenantId, entityId)`
- **Idempotency key** — `(tenantId, serviceCallId)` must be known before DB insert
- **Event correlation** — Messages reference ServiceCallId for tracing/debugging

### Identity Types

- **TenantId** — Multi-tenant partition key (external system concern)
- **ServiceCallId** — Aggregate root identifier (our primary concern)
- **CorrelationId** — Request trace ID across modules/events
- **EnvelopeId** — Message deduplication ID for broker

### Database-Generated IDs: Why They Don't Work

```typescript
// ❌ PROBLEM: Can't use ID until AFTER insert
const result = await db.insert(serviceCall).returning(["id"]);
const serviceCallId = result.id; // Only available NOW!

// ❌ Can't include in idempotency check BEFORE insert
// ❌ Can't publish events referencing serviceCallId within same transaction
// ❌ Can't return serviceCallId to client immediately (need DB roundtrip)
// ❌ Can't log with serviceCallId before persistence
```

**Fundamental issue:** Outbox pattern requires publishing events **within the same transaction** as aggregate insert. Events must reference the aggregate ID. Database-generated IDs aren't available until **after** the insert completes, creating a chicken-and-egg problem.

### Application-Generated IDs: Why They Work

```typescript
// ✅ SOLUTION: Generate ID BEFORE insert
const serviceCallId = clientProvidedId
  ?? crypto.randomUUID()  // UUID v7 preferred

// ✅ Can check idempotency BEFORE insert
const existing = await db.findBy({ tenantId, serviceCallId })
if (existing) return existing

// ✅ Can include ID in domain events
const event = ServiceCallSubmitted({ serviceCallId, ... })

// ✅ Can insert aggregate + publish events in same transaction
await db.transaction(async (tx) => {
  await tx.insert(serviceCall)
  await tx.outbox.append(event)  // References serviceCallId!
})
```

### UUID v4 vs UUID v7

- **UUID v4** — Random (122 bits entropy), no temporal ordering
  - ❌ Poor database index locality (random inserts fragment B-trees)
  - ❌ Poor cache locality (hot keys scattered across index)
  - ❌ Can't sort by creation time

- **UUID v7** — Time-ordered (48-bit millisecond timestamp + 74 bits randomness)
  - ✅ Natural insertion order (better B-tree locality)
  - ✅ Better cache hit rate (recent IDs cluster together)
  - ✅ Sortable by timestamp (useful for streams/events)
  - ✅ Sufficient entropy (74 bits random = collision-resistant)

**Decision:** Use UUID v7 for time-series data (ServiceCallId, EnvelopeId).

## Decision

### Identity Generation Responsibility Matrix

| Identity Type     | Generated By                   | When             | Format  | Notes                                        |
| ----------------- | ------------------------------ | ---------------- | ------- | -------------------------------------------- |
| **TenantId**      | External (Tenant Provisioning) | Before API call  | UUID v7 | Provided in request path/header              |
| **ServiceCallId** | Application (API or Client)    | Before DB insert | UUID v7 | Accept from client (idempotency) or generate |
| **CorrelationId** | Application (API Module)       | Request entry    | UUID v7 | Generated per request for tracing            |
| **EnvelopeId**    | Application (Publisher)        | Before publish   | UUID v7 | Generated when wrapping message              |

### No IdGeneratorPort

**Decision:** Do NOT create an `IdGeneratorPort` abstraction.

**Rationale (YAGNI):**

- UUID generation is **deterministic** (no side effects requiring mocking)
- Platform APIs are **stable** (`crypto.randomUUID()` available everywhere)
- **No business logic** to test (UUID generation is pure utility)
- Abstraction adds **complexity without benefit** (extra port, adapter, DI)

Use `crypto.randomUUID()` directly in application code. If UUID v7 library needed, import directly (not a port).

### API Pattern: Accept Optional Client IDs

```typescript
// API accepts optional serviceCallId for idempotency
interface SubmitServiceCallRequest {
  serviceCallId?: ServiceCallId; // Client-provided (idempotent retry)
  tenantId: TenantId;
  name: string;
  // ...
}

// Handler logic
const serviceCallId =
  req.body.serviceCallId ?? Schema.make(ServiceCallId)(crypto.randomUUID());

// Now have ID BEFORE any DB operation
```

This enables:

- **Idempotent retries** — Client can retry with same ID
- **Client-side ID generation** — For advanced clients who need immediate reference
- **Server-side generation** — Simple clients omit ID, server generates

## Consequences

### Positive

✅ **Idempotency works naturally** — Have `(tenantId, serviceCallId)` before DB insert  
✅ **Outbox pattern works** — Events can reference ServiceCallId within same transaction  
✅ **Immediate availability** — Can log, trace, return ID without DB roundtrip  
✅ **Event correlation** — All messages reference ServiceCallId from creation  
✅ **Client flexibility** — Clients can provide ID for idempotency or let server generate  
✅ **Better DB performance** — UUID v7 insertion order improves index locality  
✅ **Simpler architecture** — No IdGeneratorPort, no extra abstraction

### Negative

⚠️ **Validation required** — Must validate client-provided IDs at API boundary (see Migration below)  
⚠️ **Application responsibility** — Application must generate IDs (can't delegate to DB)  
⚠️ **Collision risk** — Theoretical (but UUID v7 has 74 bits randomness = negligible risk)

### Migration: Brand.nominal → Schema.brand

**Current problem:** `shared.ts` uses `Brand.nominal` (type-only, no runtime validation):

```typescript
// ❌ CURRENT: No validation!
export type TenantId = string & Brand.Brand<"TenantId">;
export const TenantId = Brand.nominal<TenantId>();

// API handler (UNSAFE):
const tenantId = req.body.tenantId as TenantId; // Accepts ANYTHING!
```

**Required fix:** Migrate to `Schema.brand` with UUID v7 validation:

```typescript
// ✅ REQUIRED: Runtime validation
import * as Schema from "effect/Schema";

export class TenantId extends Schema.String.pipe(
  Schema.pattern(
    /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
    {
      message: () => "TenantId must be a valid UUID v7",
    },
  ),
  Schema.brand("TenantId"),
) {}

// API handler (SAFE):
const tenantId = yield * Schema.decode(TenantId)(req.body.tenantId);
// ✅ Validates format! Rejects invalid input with clear error
```

**Action:** Update `packages/contracts/src/types/shared.ts` to use `Schema.brand` for all ID types (TenantId, ServiceCallId, CorrelationId, EnvelopeId).

## References

- [ADR-0006: Idempotency Strategy][ADR-0006] — Idempotency key design
- [ADR-0004: Database Choice][ADR-0004] — Database role (storage, not ID generation)
- [ADR-0008: Outbox Pattern][ADR-0008] — Why IDs must exist before transaction commit
- [RFC 9562: UUID v7 Specification](https://www.rfc-editor.org/rfc/rfc9562.html#name-uuid-version-7)

[ADR-0004]: ./ADR-0004-database.md
[ADR-0006]: ./ADR-0006-idempotency.md
[ADR-0008]: ./ADR-0008-outbox.md
