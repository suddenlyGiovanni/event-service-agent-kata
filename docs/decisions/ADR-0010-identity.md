# ADR-0010: Identity Generation Strategy

Status: Accepted

## Problem

Who generates entity identifiers (TenantId, ServiceCallId, CorrelationId, EnvelopeId) and when? Options include:

1. **Client-generated** — External systems provide IDs
2. **Application-generated** — Application code creates IDs before persistence
3. **Database-generated** — Database assigns IDs on INSERT (AUTOINCREMENT, SERIAL, triggers)
4. **Broker-generated** — Message broker assigns IDs during publish

Each approach has implications for idempotency, event correlation, outbox pattern, and API contracts.

## Context

### System Requirements

- **Event-driven architecture** — At-least-once delivery, idempotent processing ([ADR-0006][])
- **Outbox pattern** — Publish domain events within database transaction ([ADR-0008][])
- **Multi-tenant** — All aggregates keyed by `(tenantId, entityId)`
- **Idempotency key** — `(tenantId, serviceCallId)` must be known before DB insert
- **Event correlation** — Messages reference ServiceCallId for tracing/debugging

### Identity Types

- **TenantId** — Multi-tenant partition key (external system concern)
- **ServiceCallId** — Aggregate root identifier (our primary concern)
- **CorrelationId** — Request trace ID across modules/events
- **EnvelopeId** — Message deduplication ID for broker

### Database-Generated IDs: Why They Don't Work

```typescript
// ❌ PROBLEM: Can't use ID until AFTER insert
const result = await db.insert(serviceCall).returning(["id"]);
const serviceCallId = result.id; // Only available NOW!

// ❌ Can't include in idempotency check BEFORE insert
// ❌ Can't publish events referencing serviceCallId within same transaction
// ❌ Can't return serviceCallId to client immediately (need DB roundtrip)
// ❌ Can't log with serviceCallId before persistence
```

**Fundamental issue:** Outbox pattern requires publishing events **within the same transaction** as aggregate insert. Events must reference the aggregate ID. Database-generated IDs aren't available until **after** the insert completes, creating a chicken-and-egg problem.

### Application-Generated IDs: Why They Work

```typescript
// ✅ SOLUTION: Generate ID BEFORE insert
const serviceCallId = clientProvidedId
  ?? crypto.randomUUID()  // UUID v7 preferred

// ✅ Can check idempotency BEFORE insert
const existing = await db.findBy({ tenantId, serviceCallId })
if (existing) return existing

// ✅ Can include ID in domain events
const event = ServiceCallSubmitted({ serviceCallId, ... })

// ✅ Can insert aggregate + publish events in same transaction
await db.transaction(async (tx) => {
  await tx.insert(serviceCall)
  await tx.outbox.append(event)  // References serviceCallId!
})
```

### UUID v4 vs UUID v7

- **UUID v4** — Random (122 bits entropy), no temporal ordering
  - ❌ Poor database index locality (random inserts fragment B-trees)
  - ❌ Poor cache locality (hot keys scattered across index)
  - ❌ Can't sort by creation time

- **UUID v7** — Time-ordered (48-bit millisecond timestamp + 74 bits randomness)
  - ✅ Natural insertion order (better B-tree locality)
  - ✅ Better cache hit rate (recent IDs cluster together)
  - ✅ Sortable by timestamp (useful for streams/events)
  - ✅ Sufficient entropy (74 bits random = collision-resistant)

**Decision:** Use UUID v7 for time-series data (ServiceCallId, EnvelopeId).

## Decision

### Identity Generation Responsibility Matrix

| Identity Type     | Generated By                   | When             | Format  | Notes                                        |
| ----------------- | ------------------------------ | ---------------- | ------- | -------------------------------------------- |
| **TenantId**      | External (Tenant Provisioning) | Before API call  | UUID v7 | Provided in request path/header              |
| **ServiceCallId** | Application (API or Client)    | Before DB insert | UUID v7 | Accept from client (idempotency) or generate |
| **CorrelationId** | Application (API Module)       | Request entry    | UUID v7 | Generated per request for tracing            |
| **EnvelopeId**    | Application (Publisher)        | Before publish   | UUID v7 | Generated when wrapping message              |

### No IdGeneratorPort

**Decision:** Do NOT create an `IdGeneratorPort` abstraction.

**Rationale (YAGNI):**

- UUID generation is **deterministic** (no side effects requiring mocking)
- Platform APIs are **stable** (`crypto.randomUUID()` available everywhere)
- **No business logic** to test (UUID generation is pure utility)
- Abstraction adds **complexity without benefit** (extra port, adapter, DI)

Use `crypto.randomUUID()` directly in application code. If UUID v7 library needed, import directly (not a port).

### API Pattern: Accept Optional Client IDs

```typescript
// API accepts optional serviceCallId for idempotency
interface SubmitServiceCallRequest {
  serviceCallId?: ServiceCallId; // Client-provided (idempotent retry)
  tenantId: TenantId;
  name: string;
  // ...
}

// Handler logic
const serviceCallId =
  req.body.serviceCallId ?? Schema.make(ServiceCallId)(crypto.randomUUID());

// Now have ID BEFORE any DB operation
```

This enables:

- **Idempotent retries** — Client can retry with same ID
- **Client-side ID generation** — For advanced clients who need immediate reference
- **Server-side generation** — Simple clients omit ID, server generates

## Consequences

### Positive

✅ **Idempotency works naturally** — Have `(tenantId, serviceCallId)` before DB insert  
✅ **Outbox pattern works** — Events can reference ServiceCallId within same transaction  
✅ **Immediate availability** — Can log, trace, return ID without DB roundtrip  
✅ **Event correlation** — All messages reference ServiceCallId from creation  
✅ **Client flexibility** — Clients can provide ID for idempotency or let server generate  
✅ **Better DB performance** — UUID v7 insertion order improves index locality  
✅ **Simpler architecture** — No IdGeneratorPort, no extra abstraction

### Negative

⚠️ **Validation required** — Must validate client-provided IDs at API boundary (see Migration below)  
⚠️ **Application responsibility** — Application must generate IDs (can't delegate to DB)  
⚠️ **Collision risk** — Theoretical (but UUID v7 has 74 bits randomness = negligible risk)

### Migration: Brand.nominal → Schema.brand

**Status**: ✅ **Migration Complete** (as of PL-14)

**Previous problem:** `shared.ts` used `Brand.nominal` (type-only, no runtime validation):

```typescript
// ❌ OLD: No validation!
export type TenantId = string & Brand.Brand<"TenantId">;
export const TenantId = Brand.nominal<TenantId>();

// API handler (UNSAFE):
const tenantId = req.body.tenantId as TenantId; // Accepts ANYTHING!
```

**Current implementation:** Migrated to `Schema.brand` with UUID v7 validation:

```typescript
// ✅ CURRENT: Runtime validation with UUID7 schema
import * as Schema from "effect/Schema";

export class TenantId extends UUID7.pipe(Schema.brand(TenantIdBrand)) {
  static readonly makeUUID7 = (time?: DateTime.Utc) => 
    Effect.gen(function* () {
      const uuid7 = yield* Uuid7Service.randomUUIDv7(time)
      return TenantId.make(uuid7)  // Validated UUID7 → branded TenantId
    })
  
  static readonly decode = (value: string) => 
    Schema.decode(TenantId)(value)  // Validates UUID7 format!
}

// API handler (SAFE):
const tenantId = yield * TenantId.decode(req.body.tenantId);
// ✅ Validates UUID7 format! Rejects invalid input with ParseError
```

**Completed in:** `packages/schemas/src/shared/`  
**Branded types migrated:**
- TenantId → `packages/schemas/src/shared/tenant-id.schema.ts`
- ServiceCallId → `packages/schemas/src/shared/service-call-id.schema.ts`
- CorrelationId → `packages/schemas/src/shared/correlation-id.schema.ts`
- EnvelopeId → `packages/schemas/src/shared/envelope-id.schema.ts`

**Pattern:** All extend `UUID7.pipe(Schema.brand(UniqueSymbol))` for double-branding

## References

- [ADR-0006: Idempotency Strategy][ADR-0006] — Idempotency key design
- [ADR-0004: Database Choice][ADR-0004] — Database role (storage, not ID generation)
- [ADR-0008: Outbox Pattern][ADR-0008] — Why IDs must exist before transaction commit
- [RFC 9562: UUID v7 Specification](https://www.rfc-editor.org/rfc/rfc9562.html#name-uuid-version-7)

[ADR-0004]: ./ADR-0004-database.md
[ADR-0006]: ./ADR-0006-idempotency.md
[ADR-0008]: ./ADR-0008-outbox.md
