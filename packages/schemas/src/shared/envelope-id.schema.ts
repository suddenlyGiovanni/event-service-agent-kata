/**
 * EnvelopeId Schema
 *
 * Branded UUID7 type for message envelope identification.
 *
 * **Purpose — Message Identity and Causation Tracking**: EnvelopeId uniquely identifies a message envelope in the
 * system, serving dual purposes:
 *
 * 1. **Deduplication**: Prevents duplicate message processing (broker idempotency)
 * 2. **Causation Chain**: Links child messages to parent (envelope.causationId = parent.envelopeId)
 *
 * **EnvelopeId vs ServiceCallId**:
 *
 * - **EnvelopeId**: Identifies a single message/event instance (ephemeral, message-level)
 * - **ServiceCallId**: Identifies aggregate instance (persistent, domain-level)
 *
 * Every event/command gets its own EnvelopeId, even if they relate to same ServiceCall.
 *
 * **Causation Chain Example**:
 *
 * ```
 * Command: SubmitServiceCall
 *   envelope.id = env-1 (EnvelopeId)
 *   causationId = None (no parent)
 *
 * Event: ServiceCallSubmitted
 *   envelope.id = env-2 (EnvelopeId)
 *   causationId = Some(env-1) ← Points to command that triggered this
 *
 * Command: ScheduleTimer
 *   envelope.id = env-3 (EnvelopeId)
 *   causationId = Some(env-2) ← Points to event that triggered this
 * ```
 *
 * This creates a causality DAG (Directed Acyclic Graph) enabling:
 *
 * - "What triggered this message?" (look at causationId)
 * - "What did this message trigger?" (query: where causationId = this.envelopeId)
 * - Full causality reconstruction for debugging
 *
 * **Deduplication Strategy**: Message broker uses envelope.id for deduplication window (e.g., 5 minutes). If same
 * envelope.id published twice, second publish is ignored (at-most-once per dedup window, at-least-once across
 * windows).
 *
 * **Why UUID7**:
 *
 * - Time-ordered for natural chronological sorting
 * - Globally unique (no coordination needed)
 * - Embedded timestamp (extract message creation time)
 *
 * Type Structure: `string & Brand<UUID7Brand> & Brand<EnvelopeIdBrand>`
 *
 * - Cannot be confused with ServiceCallId, TenantId, or CorrelationId
 * - Runtime validation via Effect Schema
 *
 * @see docs/design/ports.md#event-publishing-pattern — Envelope structure
 * @see docs/decisions/ADR-0002-broker.md — Deduplication strategy
 */

/* biome-ignore-all lint/style/useNamingConvention: UUID7/makeUUID7 follow Effect conventions */

import type * as DateTime from 'effect/DateTime'
import * as Effect from 'effect/Effect'
import type * as Either from 'effect/Either'
import type * as ParseResult from 'effect/ParseResult'
import * as Schema from 'effect/Schema'

import * as Service from '@event-service-agent/platform/uuid7'

import { UUID7 } from './uuid7.schema.ts'

/**
 * EnvelopeId brand for internal use
 */
const EnvelopeIdBrand: unique symbol = Symbol.for('@event-service-agent/schemas/shared/EnvelopeId')

/**
 * EnvelopeId — Branded UUID7 for message envelope identification
 *
 * Uniquely identifies a message envelope for deduplication and causation tracking. Generated by adapter when wrapping
 * domain events into MessageEnvelope.
 */
export class EnvelopeId extends UUID7.pipe(Schema.brand(EnvelopeIdBrand)) {
	/**
	 * Generate a new EnvelopeId using UUID version 7
	 *
	 * Creates time-ordered identifier for a new message envelope. UUID7's timestamp prefix enables chronological message
	 * ordering and causality reconstruction.
	 *
	 * **When to use**:
	 *
	 * - Adapter wrapping domain event into MessageEnvelope (most common)
	 * - Testing with deterministic envelope IDs
	 *
	 * **Who generates**: Adapters generate EnvelopeId when publishing domain events. Workflows never generate EnvelopeId
	 * directly — they work with pure domain events, and the adapter wraps them with infrastructure metadata (envelope.id,
	 * timestamp, etc).
	 *
	 * **Application-Generated IDs (per ADR-0010)**: EnvelopeId generated in application code (adapter), not broker. This
	 * enables:
	 *
	 * - Pre-publishing correlation (ID known before broker ACK)
	 * - Deterministic testing (can control exact envelope IDs)
	 * - Causation tracking (child's causationId = parent's envelope.id)
	 *
	 * @example Adapter generates envelope ID when publishing
	 *
	 * ```typescript
	 * import type * as DateTime from 'effect/DateTime'
	 * import * as Effect from 'effect/Effect'
	 * import * as Option from 'effect/Option'
	 *
	 * import { MessageMetadata } from '@event-service-agent/platform/context'
	 * import { EventBusPort } from '@event-service-agent/platform/ports'
	 *
	 * import { MessageEnvelope } from '../envelope/index.ts'
	 * import type { DueTimeReached } from '../messages/timer/events.schema.ts'
	 * import type { ServiceCallId } from './service-call-id.schema.ts'
	 * import type { TenantId } from './tenant-id.schema.ts'
	 *
	 * declare const domainEvent: DueTimeReached.Type
	 * declare const tenantId: TenantId.Type
	 * declare const timestampMs: DateTime.Utc
	 * declare const serviceCallId: ServiceCallId.Type
	 *
	 * // Adapter wraps domain event with envelope
	 * export const _program = Effect.gen(function* () {
	 * 	const eventBus = yield* EventBusPort
	 *
	 * 	const { correlationId } = yield* MessageMetadata // correlationId, causationId
	 *
	 * 	const envelope = new MessageEnvelope({
	 * 		aggregateId: Option.some(serviceCallId),
	 * 		// Points to parent message
	 * 		causationId: Option.none(),
	 *
	 * 		// Traces to original request
	 * 		correlationId,
	 *
	 * 		// Unique ID for this message
	 * 		id: yield* EnvelopeId.makeUUID7(),
	 * 		payload: domainEvent,
	 *
	 * 		tenantId,
	 * 		timestampMs,
	 * 		type: 'DueTimeReached',
	 * 	})
	 *
	 * 	yield* eventBus.publish([envelope])
	 * })
	 * ```
	 *
	 * @example Causation chain in command handler
	 *
	 * ```typescript
	 * import type * as DateTime from 'effect/DateTime'
	 * import * as Effect from 'effect/Effect'
	 * import * as Option from 'effect/Option'
	 *
	 * import { MessageMetadata } from '@event-service-agent/platform/context'
	 * import { EventBusPort } from '@event-service-agent/platform/ports'
	 *
	 * import { MessageEnvelope } from '../envelope/index.ts'
	 * import type { ServiceCallScheduled } from '../messages/orchestration/events.schema.ts'
	 * import type { ServiceCallId } from './service-call-id.schema.ts'
	 * import type { TenantId } from './tenant-id.schema.ts'
	 *
	 * declare const domainEvent: ServiceCallScheduled.Type
	 * declare const tenantId: TenantId.Type
	 * declare const timestampMs: DateTime.Utc
	 * declare const serviceCallId: ServiceCallId.Type
	 * declare const parentEnvelopeId: EnvelopeId.Type
	 *
	 * // Handler processes command and publishes event with causation link
	 * export const _program = Effect.gen(function* () {
	 * 	const eventBus = yield* EventBusPort
	 *
	 * 	const { correlationId } = yield* MessageMetadata
	 *
	 * 	const envelope = new MessageEnvelope({
	 * 		aggregateId: Option.some(serviceCallId),
	 * 		// Links to parent command that triggered this event
	 * 		causationId: Option.some(parentEnvelopeId),
	 *
	 * 		// Traces to original request
	 * 		correlationId,
	 *
	 * 		// NEW envelope ID for this child message
	 * 		id: yield* EnvelopeId.makeUUID7(),
	 * 		payload: domainEvent,
	 *
	 * 		tenantId,
	 * 		timestampMs,
	 * 		type: 'ServiceCallScheduled',
	 * 	})
	 *
	 * 	yield* eventBus.publish([envelope])
	 * })
	 * ```
	 *
	 * @param time - Optional UTC timestamp for deterministic generation
	 *
	 * @returns Effect producing validated EnvelopeId
	 * @throws ParseError - If generated UUID7 fails validation (extremely rare)
	 * @requires UUID7 - Service for UUID generation
	 */
	static readonly makeUUID7: (
		time?: DateTime.Utc,
	) => Effect.Effect<EnvelopeId.Type, ParseResult.ParseError, Service.UUID7> = (time) =>
		Service.UUID7.pipe(
			Effect.flatMap(({ randomUUIDv7 }) => randomUUIDv7(time)),
			/*
			 * Use make() instead of decode() — UUID7 service already validates.
			 * Avoids redundant validation for performance.
			 */
			Effect.map((uuid7: UUID7.Type): EnvelopeId.Type => EnvelopeId.make(uuid7)),
		)

	/**
	 * Decode string to EnvelopeId with validation
	 *
	 * Use for parsing broker messages, logs, or debugging tools.
	 *
	 * @param value - String to validate and brand
	 *
	 * @returns Effect with validated EnvelopeId
	 * @throws ParseError - If value is not valid UUID7
	 */
	static readonly decode: (value: string) => Effect.Effect<EnvelopeId.Type, ParseResult.ParseError> = (value) =>
		Schema.decode(EnvelopeId)(value)

	/**
	 * Decode string to EnvelopeId (Either variant)
	 *
	 * @param value - String to validate
	 *
	 * @returns Either with EnvelopeId or ParseError
	 */
	static readonly decodeEither: (value: string) => Either.Either<EnvelopeId.Type, ParseResult.ParseError> = (value) =>
		Schema.decodeEither(EnvelopeId)(value)
}

/**
 * Type aliases for EnvelopeId
 *
 * Provides convenient access to the branded type.
 */
export declare namespace EnvelopeId {
	/**
	 * The branded type: string & Brand<UUID7Brand> & Brand<EnvelopeIdBrand>
	 */
	type Type = typeof EnvelopeId.Type
}
