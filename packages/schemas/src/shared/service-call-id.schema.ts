/**
 * ServiceCallId Schema
 *
 * Branded UUID7 type for service call aggregate identification.
 *
 * **Domain Model — ServiceCall as Aggregate Root**:
 * ServiceCall is the single aggregate in the MVP system. Every domain event and
 * command that manipulates ServiceCall state carries a ServiceCallId to identify
 * which aggregate instance is being operated on.
 *
 * **Why ServiceCallId exists**:
 * - **Message Ordering**: Used as partition key (with TenantId) to guarantee
 *   event ordering per aggregate instance in message broker
 * - **Idempotency**: Commands keyed by (TenantId, ServiceCallId) are idempotent
 * - **State Isolation**: Each ServiceCall has independent state lifecycle
 * - **Type Safety**: Prevents using TenantId where ServiceCallId is expected
 *
 * **Per-Aggregate Ordering (see ADR-0002)**:
 * Messages with same (TenantId, ServiceCallId) are processed in order:
 * 1. SubmitServiceCall → ServiceCallSubmitted
 * 2. ScheduleTimer → ServiceCallScheduled
 * 3. DueTimeReached → ExecuteServiceCall
 * 4. ExecutionSucceeded → ServiceCallSucceeded
 *
 * Broker ensures ordering by routing messages with same ServiceCallId to same
 * partition. Out-of-order processing would violate state machine invariants.
 *
 * Type Structure: `string & Brand<UUID7Brand> & Brand<ServiceCallIdBrand>`
 * - Cannot be confused with TenantId, CorrelationId, or EnvelopeId
 * - Runtime validation via Effect Schema
 * - Compile-time type safety
 *
 * @see docs/design/domain.md — ServiceCall aggregate design
 * @see docs/decisions/ADR-0002-broker.md — Partition key strategy
 * @see docs/decisions/ADR-0010-identity.md — Identity generation
 */

/* biome-ignore-all lint/style/useNamingConvention: UUID7/makeUUID7 follow Effect conventions */

import type * as DateTime from 'effect/DateTime'
import * as Effect from 'effect/Effect'
import type * as Either from 'effect/Either'
import type * as ParseResult from 'effect/ParseResult'
import * as Schema from 'effect/Schema'

import * as Service from '@event-service-agent/platform/uuid7'

import { UUID7 } from './uuid7.schema.ts'

const ServiceCallIdBrand: unique symbol = Symbol.for('@event-service-agent/schemas/shared/ServiceCallId')

/**
 * ServiceCallId — Branded UUID7 for service call aggregate identification
 *
 * Identifies a unique instance of the ServiceCall aggregate. All events and
 * commands for this aggregate instance share the same ServiceCallId.
 */
export class ServiceCallId extends UUID7.pipe(Schema.brand(ServiceCallIdBrand)) {
	/**
	 * Generate a new ServiceCallId using UUID version 7
	 *
	 * Creates time-ordered identifier for a new ServiceCall aggregate instance.
	 * UUID7's timestamp prefix enables chronological sorting and correlation.
	 *
	 * **When to use**:
	 * - Creating new ServiceCall (API receives SubmitServiceCall command)
	 * - Testing with deterministic IDs
	 *
	 * **Application-Generated IDs (per ADR-0010)**:
	 * ServiceCallId is generated by API module when receiving HTTP request, enabling:
	 * - Idempotency: Retry same request with same ID
	 * - Early correlation: ID available before event publishing
	 * - Client-side ID generation (future): Client can generate ID upfront
	 *
	 * @param time - Optional UTC timestamp for deterministic generation
	 * @returns Effect producing validated ServiceCallId
	 * @throws ParseError - If generated UUID7 fails validation (extremely rare)
	 * @requires UUID7 - Service for UUID generation
	 *
	 * @example API module creates ServiceCall
	 * ```typescript
	 * const handleSubmitRequest = Effect.gen(function* () {
	 *   const serviceCallId = yield* ServiceCallId.makeUUID7()
	 *   const command = new SubmitServiceCall({
	 *     tenantId,
	 *     serviceCallId, // ID generated before publishing command
	 *     requestSpec: httpRequest
	 *   })
	 *   yield* eventBus.publish(command)
	 *   return serviceCallId // Return to client for polling/tracking
	 * })
	 * ```
	 */
	static readonly makeUUID7: (
		time?: DateTime.Utc,
	) => Effect.Effect<ServiceCallId.Type, ParseResult.ParseError, Service.UUID7> = time =>
		Service.UUID7.pipe(
			Effect.flatMap(({ randomUUIDv7 }) => randomUUIDv7(time)),
			/*
			 * Use make() instead of decode() — UUID7 service already validates.
			 * Avoids redundant validation for performance.
			 */
			Effect.map((uuid7: UUID7.Type): ServiceCallId.Type => ServiceCallId.make(uuid7)),
		)

	/**
	 * Decode string to ServiceCallId with validation
	 *
	 * @param value - String to validate and brand
	 * @returns Effect with validated ServiceCallId
	 * @throws ParseError - If value is not valid UUID7
	 */
	static readonly decode: (value: string) => Effect.Effect<ServiceCallId.Type, ParseResult.ParseError> = value =>
		Schema.decode(ServiceCallId)(value)

	/**
	 * Decode string to ServiceCallId (Either variant)
	 *
	 * @param value - String to validate
	 * @returns Either with ServiceCallId or ParseError
	 */
	static readonly decodeEither: (value: string) => Either.Either<ServiceCallId.Type, ParseResult.ParseError> = value =>
		Schema.decodeEither(ServiceCallId)(value)
}

/**
 * Type aliases for ServiceCallId
 *
 * Provides convenient access to the branded type.
 */
export declare namespace ServiceCallId {
	/**
	 * The branded type: string & Brand<UUID7Brand> & Brand<ServiceCallIdBrand>
	 */
	type Type = typeof ServiceCallId.Type
}
