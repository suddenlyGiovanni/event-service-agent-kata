/** biome-ignore-all lint/style/useNamingConvention: Effect Layer pattern uses PascalCase for static layer properties */
import * as DateTime from 'effect/DateTime'
import * as Effect from 'effect/Effect'
import * as Layer from 'effect/Layer'
import * as Option from 'effect/Option'

import type * as Messages from '@event-service-agent/platform/messages'
import { PublishError } from '@event-service-agent/platform/ports'
import { Topics } from '@event-service-agent/platform/routing'
import { UUID7 } from '@event-service-agent/schemas'
import { MessageEnvelopeSchema } from '@event-service-agent/schemas/envelope'
import { type CorrelationId, EnvelopeId, Iso8601DateTime } from '@event-service-agent/schemas/shared'

import { DueTimeReached } from '../domain/events.domain.ts'
import type { TimerEntry } from '../domain/timer-entry.domain.ts'
import { EventBusPort, TimerEventBusPort } from '../ports/index.ts'

export class TimerEventBus {
	/**
	 * Live adapter implementation that composes over shared EventBusPort
	 *
	 * Layer requirements:
	 * - EventBusPort: Shared broker abstraction
	 * - UUID7: Service for generating validated EnvelopeId
	 */
	static readonly Live: Layer.Layer<TimerEventBusPort, never, EventBusPort> = Layer.effect(
		TimerEventBusPort,
		Effect.gen(function* () {
			const sharedBus = yield* EventBusPort

			return TimerEventBusPort.of({
				publishDueTimeReached: Effect.fn('Timer.publishDueTimeReached')(function* (
					scheduledTimer: TimerEntry.ScheduledTimer,
					firedAt: DateTime.Utc,
				) {
					const { tenantId, correlationId, serviceCallId } = scheduledTimer

					/**
					 * Build DueTimeReached event DTO
					 * TODO: this DTO should be generated by the Encoding step of a DueTimeReached schema
					 */
					const dueTimeReached = new DueTimeReached({
						reachedAt: Iso8601DateTime.make(DateTime.formatIso(firedAt)),
						serviceCallId,
						tenantId,
					})

					/**
					 * Build envelope with generated EnvelopeId
					 * Provide UUID7 service locally to eliminate from requirements
					 */
					const envelopeId: EnvelopeId.Type = yield* EnvelopeId.makeUUID7().pipe(
						Effect.provide(UUID7.Default), // TODO: move the UUID7 requirement to another layer?
						Effect.mapError(
							parseError =>
								new PublishError({
									cause: `Failed to generate EnvelopeId: ${parseError}`,
								}),
						),
					)

					/**
					 * Build self-contained envelope with all routing metadata
					 *
					 * No separate context needed - envelope contains:
					 * - tenantId: For multi-tenancy and routing (required)
					 * - correlationId: For distributed tracing (optional - autonomous events may lack this)
					 * - aggregateId: Would be serviceCallId if we needed per-aggregate ordering
					 * - timestampMs: Event occurrence time
					 */
					const envelope: MessageEnvelopeSchema.Type = new MessageEnvelopeSchema({
						...Option.match(correlationId, {
							onNone: () => ({}),
							onSome: correlationId => ({ correlationId }),
						}),
						id: envelopeId,
						payload: dueTimeReached,
						tenantId,
						timestampMs: firedAt.epochMillis,
						type: 'DueTimeReached',
					})

					// Delegate to shared bus - envelope is self-contained!
					yield* sharedBus.publish([envelope])
				}),

				subscribeToScheduleTimerCommands: Effect.fn('Timer.subscribeToScheduleTimerCommands')(function* <E>(
					handler: (
						command: Messages.Orchestration.Commands.ScheduleTimer,
						correlationId?: CorrelationId.Type,
					) => Effect.Effect<void, E>,
				) {
					yield* sharedBus.subscribe([Topics.Timer.Commands], (envelope: Message.Envelope) =>
						Effect.gen(function* () {
							// 1. Type guard: Ensure it's a ScheduleTimer command
							if (envelope.type !== 'ScheduleTimer') {
								// Log and ignore unexpected message types to keep consumer alive
								return yield* Effect.logDebug('Ignoring non-ScheduleTimer message', {
									receivedType: envelope.type,
								})
							}

							// 2. Extract and validate payload (with type assertion for now)
							// TODO: When schemas exist, use Schema.decode(ScheduleTimer)(envelope.payload)
							const { payload: command, correlationId } =
								envelope as Message.Envelope<Messages.Orchestration.Commands.ScheduleTimer>

							// 3. Delegate to handler
							yield* handler(command, correlationId)
						}),
					)
				}),
			})
		}),
	)
}
